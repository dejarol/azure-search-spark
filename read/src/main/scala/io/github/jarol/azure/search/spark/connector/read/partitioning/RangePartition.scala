package io.github.jarol.azure.search.spark.connector.read.partitioning

/**
 * Search partition returned by a [[RangePartitioner]]
 * <br>
 * The filter generated by an instance of this class combines the values of the 3 sub filters (
 * the one provided by the <code>optionsBuilder</code>, [[lowerBound]] and [[upperBound]])
 *  - if [[lowerBound]] is defined, it will generate a filter {{{
 *    field >= lowerBound
 *  }}}
 *  - if [[upperBound]] is defined, it will generate a filter {{{
 *    field < upperbound
 *  }}}
 * These two filters will be combined in a single filter that eventually includes also
 * the one provided by the <code>optionsBuilder</code> (if defined).
 * If all 3 are defined, the overall filter will be
 * {{{
 *   field >= lowerBound and field < upperbound and inputFilter
 * }}}
 * i.e. it represents the logical AND of the 3 sub filters
 *
 * @param partitionId partition id
 * @param fieldName field name
 * @param lowerBound range lower bound (inclusive)
 * @param upperBound range upper bound (exclusive)
 */

case class RangePartition(
                           override protected val partitionId: Int,
                           private val fieldName: String,
                           private val lowerBound: Option[String],
                           private val upperBound: Option[String]
                         )
  extends AbstractSearchPartition(partitionId) {

  override def getPartitionFilter: String = {

    (lowerBound, upperBound) match {
      case (Some(l), Some(u)) => s"${getGeFilter(l)} and ${getLtFilter(u)}"
      case (Some(l), None) => getGeFilter(l)
      case (None, Some(u)) => s"${getLtFilter(u)} or $fieldName eq null"
      case (None, None) => null
    }
  }

  private def getGeFilter(value: String): String = s"$fieldName ge $value"

  private def getLtFilter(value: String) = s"$fieldName lt $value"
}

object RangePartition {

  /**
   * Create a collection of partitions
   * @param fieldName partition field name
   * @param values partition values
   * @return a collection of partitions
   */

  def createCollection(
                        fieldName: String,
                        values: Seq[String]
                      ): Seq[RangePartition] = {

    val lowerValues: Seq[Option[String]] = None +: values.map(Some(_))
    val upperValues: Seq[Option[String]] = values.map(Some(_)) :+ None

    // Zip lower values with upper values and create the partitions
    lowerValues.zip(upperValues).zipWithIndex.map {
      case ((lb, ub), index) =>
        RangePartition(index, fieldName, lb, ub)
    }
  }
}
