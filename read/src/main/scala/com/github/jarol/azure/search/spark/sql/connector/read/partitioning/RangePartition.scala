package com.github.jarol.azure.search.spark.sql.connector.read.partitioning

import com.github.jarol.azure.search.spark.sql.connector.read.filter.V2ExpressionAdapter

/**
 * Search partition returned by a [[RangePartitioner]]
 * <br>
 * The filter generated by an instance of this class combines the values of the 3 sub filters ([[inputFilter]], [[lowerBound]] and [[upperBound]])
 *  - if [[lowerBound]] is defined, it will generate a filter {{{
 *    field >= lowerBound
 *  }}}
 *  - if [[upperBound]] is defined, it will generate a filter {{{
 *    field < upperbound
 *  }}}
 * These two filters will be combined in a single filter that eventually includes also the value of [[inputFilter]] (if defined).
 * If all 3 are defined, the overall filter will be
 * {{{
 *   field >= lowerBound and field < upperbound and inputFilter
 * }}}
 * i.e. it represents the logical AND of the 3 sub filters
 *
 * @param partitionId partition id
 * @param inputFilter optional filter to apply during data retrieval
 * @param maybeSelect optional list of index fields to select
 * @param fieldName field name
 * @param lowerBound range lower bound (inclusive)
 * @param upperBound range upper bound (exclusive)
 */

case class RangePartition(
                           override protected val partitionId: Int,
                           override protected val inputFilter: Option[String],
                           override protected val maybeSelect: Option[Seq[String]],
                           override protected val pushedPredicates: Array[V2ExpressionAdapter],
                           private val fieldName: String,
                           private val lowerBound: Option[String],
                           private val upperBound: Option[String])
  extends AbstractSearchPartition(partitionId, inputFilter, maybeSelect, pushedPredicates) {

  override final protected[partitioning] def partitionFilter: Option[String] = {

    (lowerBound, upperBound) match {
      case (Some(l), Some(u)) => Some(s"${getGeFilter(l)} and ${getLtFilter(u)}")
      case (Some(l), None) => Some(getGeFilter(l))
      case (None, Some(u)) => Some(s"${getLtFilter(u)} or $fieldName eq null")
      case (None, None) => None
    }
  }

  private def getGeFilter(value: String): String = s"$fieldName ge $value"

  private def getLtFilter(value: String) = s"$fieldName lt $value"
}

object RangePartition {

  /**
   * Create a collection of partitions
   * @param inputFilter input filter
   * @param maybeSelect fields to select
   * @param fieldName partition field name
   * @param values partition values
   * @return a collection of partitions
   */

  def createCollection(
                        inputFilter: Option[String],
                        maybeSelect: Option[Seq[String]],
                        pushedPredicates: Array[V2ExpressionAdapter],
                        fieldName: String,
                        values: Seq[String]
                      ): Seq[RangePartition] = {

    val lowerValues: Seq[Option[String]] = None +: values.map(Some(_))
    val upperValues: Seq[Option[String]] = values.map(Some(_)) :+ None

    // Zip lower values with upper values and create the partitions
    lowerValues.zip(upperValues).zipWithIndex.map {
      case ((lb, ub), index) => RangePartition(
        index,
        inputFilter,
        maybeSelect,
        pushedPredicates,
        fieldName,
        lb, ub
      )
    }
  }
}
