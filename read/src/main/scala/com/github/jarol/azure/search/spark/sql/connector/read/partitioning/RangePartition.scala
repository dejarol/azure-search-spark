package com.github.jarol.azure.search.spark.sql.connector.read.partitioning

/**
 * Search partition returned by a [[RangePartitioner]]
 * <br>
 * The filter generated by an instance of this class combines the values of the 3 sub filters ([[inputFilter]], [[lowerBound]] and [[upperBound]])
 *  - if [[lowerBound]] is defined, it will generate a filter {{{
 *    field >= lowerBound
 *  }}}
 *  - if [[upperBound]] is defined, it will generate a filter {{{
 *    field < upperbound
 *  }}}
 * These two filters will be combined in a single filter that eventually includes also the value of [[inputFilter]] (if defined).
 * If all 3 are defined, the overall filter will be
 * {{{
 *   field >= lowerBound and field < upperbound and inputFilter
 * }}}
 * i.e. it represents the logical AND of the 3 sub filters
 * @param partitionId partition id
 * @param inputFilter optional filter to apply during data retrieval
 * @param maybeSelect optional list of index fields to select
 * @param fieldName field name
 * @param lowerBound range lower bound (inclusive)
 * @param upperBound range upper bound (exclusive)
 */

case class RangePartition(override protected val partitionId: Int,
                          override protected val inputFilter: Option[String],
                          override protected val maybeSelect: Option[Seq[String]],
                          private val fieldName: String,
                          private val lowerBound: Option[String],
                          private val upperBound: Option[String])
  extends SearchPartitionTemplate(partitionId, inputFilter, maybeSelect) {

  override def getSearchFilter: String = {

    // Collect defined filters
    val lowerFilter = lowerBound.map(v => s"$fieldName ge $v")
    val upperFilter = upperBound.map(v => s"$fieldName lt $v")
    val definedFilters = Seq(lowerFilter, upperFilter, inputFilter)
      .collect {
        case Some(value) => value
    }

    if (definedFilters.isEmpty) {
      null
    } else {
      definedFilters.mkString(" and ")
    }
  }
}

object RangePartition {

  /**
   * Create a collection of partitions
   * @param inputFilter input filter
   * @param maybeSelect fields to select
   * @param fieldName partition field name
   * @param values partition values
   * @return a collection of partitions
   */

  def createCollection(
                      inputFilter: Option[String],
                      maybeSelect: Option[Seq[String]],
                      fieldName: String,
                      values: Seq[String]
                      ): Seq[RangePartition] = {

    val lowerValues: Seq[Option[String]] = None +: values.map(Some(_))
    val upperValues: Seq[Option[String]] = values.map(Some(_)) :+ None

    // Zip lower values with upper values and create the partitions
    lowerValues.zip(upperValues).zipWithIndex.map {
      case ((lb, ub), index) => RangePartition(
        index,
        inputFilter,
        maybeSelect,
        fieldName,
        lb, ub
      )
    }
  }
}
