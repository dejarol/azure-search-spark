package io.github.dejarol.azure.search.spark.connector.write.config

import com.azure.search.documents.indexes.models.{LexicalAnalyzerName, SearchField, SearchFieldDataType}
import io.github.dejarol.azure.search.spark.connector.{BasicSpec, FieldFactory, JsonMixIns}

class SearchFieldAttributesSpec
  extends BasicSpec
    with JsonMixIns
      with FieldFactory {

  private lazy val lexicalAnalyzer = LexicalAnalyzerName.AR_LUCENE
  private lazy val emptyOptions = SearchFieldAttributes.empty()

  /**
   * Assert the behavior of the action generated by a config built from a single-paired map.
   * @param value single value to add to the config
   * @param copyFunction function for creating a new version of the config
   * @param assertion assertion to run on a Search field, for asserting the action effect
   * @tparam A value type
   */

  private def assertBehaviorOfGeneratedAction[A](
                                                  value: A,
                                                  copyFunction: (SearchFieldAttributes, A) => SearchFieldAttributes
                                                )(
    assertion: SearchField => Unit
  ): Unit = {

    // On an empty config, the action should be empty
    emptyOptions.toAction shouldBe empty

    // On the new config, the action should be defined
    val actualAction = copyFunction(emptyOptions, value).toAction
    actualAction shouldBe defined

    val modifiedField = actualAction.get.apply(
      createSearchField("hello", SearchFieldDataType.STRING)
    )

    assertion(modifiedField)
  }

  describe(anInstanceOf[SearchFieldAttributes]) {
    describe(SHOULD) {
      describe("return an overall action that") {
        describe("sets") {
          it("the analyzer") {

            assertBehaviorOfGeneratedAction[LexicalAnalyzerName](
              lexicalAnalyzer,
              (o, v) => o.copy(analyzer = Some(v))
            ) {
              field =>
                field.getAnalyzerName shouldBe lexicalAnalyzer
            }
          }

          it("the index analyzer") {

            assertBehaviorOfGeneratedAction[LexicalAnalyzerName](
              lexicalAnalyzer,
              (o, v) => o.copy(indexAnalyzer = Some(v))
            ) {
              field =>
                field.getIndexAnalyzerName shouldBe lexicalAnalyzer
            }
          }

          it("the search analyzer") {

            assertBehaviorOfGeneratedAction[LexicalAnalyzerName](
              lexicalAnalyzer,
              (o, v) => o.copy(searchAnalyzer = Some(v))
            ) {
              field =>
                field.getSearchAnalyzerName shouldBe lexicalAnalyzer
            }
          }

          it("the vector search profile") {

            val profileName = "profile"
            assertBehaviorOfGeneratedAction[String](
              profileName,
              (o, v) => o.copy(vectorSearchProfile = Some(v))
            ) {
              field =>
                field.getVectorSearchProfileName shouldBe profileName
            }
          }
        }

        describe("marks the field as") {
          it("facetable") {

            assertBehaviorOfGeneratedAction[Boolean](
              true,
              (o, v) => o.copy(facetable = Some(v))
            ) {
              field =>
                field.isFacetable shouldBe true
            }
          }

          it("filterable") {

            assertBehaviorOfGeneratedAction[Boolean](
              true,
              (o, v) => o.copy(filterable = Some(v))
            ) {
              field =>
                field.isFilterable shouldBe true
            }
          }

          it("key") {

            assertBehaviorOfGeneratedAction[Boolean](
              true,
              (o, v) => o.copy(key = Some(v))
            ) {
              field =>
                field.isKey shouldBe true
            }
          }

          it("retrievable") {

            assertBehaviorOfGeneratedAction[Boolean](
              false,
              (o, v) => o.copy(retrievable = Some(v))
            ) {
              field =>
                field.isHidden shouldBe true
            }
          }

          it("sortable") {

            assertBehaviorOfGeneratedAction[Boolean](
              true,
              (o, v) => o.copy(sortable = Some(v))
            ) {
              field =>
                field.isSortable shouldBe true
            }
          }

          it("searchable") {

            assertBehaviorOfGeneratedAction[Boolean](
              true,
              (o, v) => o.copy(searchable = Some(v))
            ) {
              field =>
                field.isSearchable shouldBe true
            }
          }
        }

        it("synonyms") {

          val synonyms = Seq("hello", "world")
          assertBehaviorOfGeneratedAction[Seq[String]](
            synonyms,
            (o, v) => o.copy(synonymMaps = Some(v))
          ) {
            field =>
              field.getSynonymMapNames should contain theSameElementsAs synonyms
          }
        }

        it("vector search dimensions") {

          val dimensions = 2
          assertBehaviorOfGeneratedAction[Int](
            dimensions,
            (o, v) => o.copy(dimensions = Some(v))
          ) {
            field =>
              field.getVectorSearchDimensions shouldBe dimensions
          }
        }

        it("folds all defined actions") {

          val copy = emptyOptions.copy(
            analyzer = Some(lexicalAnalyzer),
            facetable = Some(false)
          )

          val actualAction = copy.toAction
          actualAction shouldBe defined
          val alteredField = actualAction.get.apply(
            createSearchField("hello", SearchFieldDataType.INT32)
          )

          alteredField.getAnalyzerName shouldBe lexicalAnalyzer
          alteredField.isFacetable shouldBe false
        }
      }

      it("return a copy with key field enabled") {

        emptyOptions.key shouldBe empty
        emptyOptions.withKeyFieldEnabled.key shouldBe Some(true)
      }

      describe("be deserialized from json when") {
        it("all attributes are defined") {

          val (analyzer, indexAnalyzer, searchAnalyzer, profile) = (
            LexicalAnalyzerName.AR_LUCENE,
            LexicalAnalyzerName.BN_MICROSOFT,
            LexicalAnalyzerName.WHITESPACE,
            "hello"
          )

          val json =
            s"""
              |{
              |  "analyzer": "$analyzer",
              |  "facetable": true,
              |  "filterable": false,
              |  "indexAnalyzer": "$indexAnalyzer",
              |  "key": true,
              |  "retrievable": false,
              |  "searchAnalyzer": "$searchAnalyzer",
              |  "searchable": false,
              |  "sortable": true,
              |  "vectorSearchProfile": "$profile",
              |  "synonymMaps": ["hello", "world"],
              |  "dimensions": 2
              |}
              |""".stripMargin

          val actual = readValueAs[SearchFieldAttributes](json)
          actual.analyzer shouldBe Some(analyzer)
          actual.facetable shouldBe Some(true)
          actual.filterable shouldBe Some(false)
          actual.indexAnalyzer shouldBe Some(indexAnalyzer)
          actual.key shouldBe Some(true)
          actual.retrievable shouldBe Some(false)
          actual.searchAnalyzer shouldBe Some(searchAnalyzer)
          actual.searchable shouldBe Some(false)
          actual.sortable shouldBe Some(true)
          actual.vectorSearchProfile shouldBe Some(profile)

          val maybeSynonyms = actual.synonymMaps
          maybeSynonyms shouldBe defined
          maybeSynonyms.get should contain theSameElementsAs Seq("hello", "world")

          actual.dimensions shouldBe Some(2)
        }

        it("some attributes are missing") {

          val json =
            """
              |{
              |  "key": true
              |}
              |""".stripMargin

          val actual = readValueAs[SearchFieldAttributes](json)
          actual.analyzer shouldBe empty
          actual.facetable shouldBe empty
          actual.filterable shouldBe empty
          actual.indexAnalyzer shouldBe empty
          actual.key shouldBe Some(true)
          actual.retrievable shouldBe empty
          actual.searchAnalyzer shouldBe empty
          actual.searchable shouldBe empty
          actual.sortable shouldBe empty
          actual.vectorSearchProfile shouldBe empty
          actual.synonymMaps shouldBe empty
          actual.dimensions shouldBe empty
        }

        it("some attributes have invalid values") {

          val json =
            s"""
               |{
               |  "analyzer": "hello"
               |}
               |""".stripMargin

          val actual = readValueAs[SearchFieldAttributes](json)
          actual.analyzer shouldBe empty
        }
      }
    }
  }
}